# Концепты архитектуры `x86_64`

Несколько дней назад я написал первый пост - [Введение в ассемблер](asm_1.md), который, к моему удивлению, вызвал большой интерес:

![newscombinator](./assets/newscombinator-screenshot.png)
![reddit](./assets/reddit-screenshot.png)

Это еще сильнее замотивировало меня продолжать описывать свой путь изучения программирования на ассемблере для Linux x86_64. За эти дни я получил замечательные отзывы от различных людей в интернете. Было много благодарных слов, но что для меня важнее, было много советов и много адекватной и очень полезной критики. Особенно хочу сказать слова благодарности за замечательные отзывы следующим людям:

- [Fiennes](https://reddit.com/user/Fiennes)
- [Grienders](https://disqus.com/by/Universal178/)
- [nkurz](https://news.ycombinator.com/user?id=nkurz)

Помимо этих людей, я хочу сказать спасибо всем, кто принял участие в обсуждении на [reddit](https://www.reddit.com/r/programming/comments/2exmpu/say_hello_to_assembly_part_1_linux_x8464/). Было много разных мнений, о том, что первая часть была не очень понятна для абсолютного новичка. Поэтому я решил писать более информативные посты. Итак, начнем со вторую часть изучения программирования на ассемблере.

## Терминология и Концепты

Как я уже писал выше, я получил много комментариев от разных людей о том, что некоторые части первого поста могли оказаться неясными. Несмотря на то, что я пытался переработать первую часть, чтобы сделать некоторые вещи более понятными, главной целью было просто введение без глубокого погружения. Мы получили нашу первую программу на ассемблере, которую мы можем запустить на нашем компьютере. Теперь пришло время начать с основ. Давайте начнем с описания некоторой терминологии, которую мы увидим и будем использовать в этой и в следующих частях.

### Регистры процессора

Одной из первых концепций, с которой мы познакомились в предыдущей части, был - `регистр`. В предыдущей главе мы согласились, что `регистр` можно рассматривать как небольшую ячейку памяти. Если мы прочитаем определение в [википедии](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_(%D1%86%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D1%8F_%D1%82%D0%B5%D1%85%D0%BD%D0%B8%D0%BA%D0%B0)), то увидим, что оно не так уж и далеко от реальности:

> Регистр процессора — это быстродоступная память, доступная процессору компьютера.

Основная цель процессора — обработка данных. Чтобы обрабатывать данные, процессор должен иметь возможность доступа к этим данным. Конечно, как и упоминалось в первой статье, процессор может получать данные из [оперативной памяти](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C), но это «медленная» операция. Если мы взглянем на сайт [Задержки испольнения, которые должен знать каждый программист](https://samwho.dev/numbers), то увидим следующую картину:

> L1 cache reference = 1ns
  ...
  ...
  ...
  Main memory reference = 100ns

Доступ к [кэшу L1](https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88#%D0%A3%D1%80%D0%BE%D0%B2%D0%BD%D0%B8_%D0%BA%D1%8D%D1%88%D0%B0) в `100x` раз быстрее, чем доступ к оперативной памяти. Регистры процессора находятся ближе к процессору. Например, вы можете взглянуть на список задержек для различных инструкций [Agner Fog](https://www.agner.org/optimize/#manual_instr_tab).

Существуют разные типы регистров процессора архитектуры `x86_64`:

- Регистры общего назначения
- Регистры сегментов
- Регистры RFLAGS
- Регистры управления
- Регистры, специфичные для архитектуры
- Регистры отладки
- Регистры x87 FPU
- Регистры MMX
- Регистры XMM
- Регистры YMM
- Регистры ZMM
- Регистры защиты памяти
- Регистры управления памятью

Подробное описание любого типа регистров вы можете найти в [руководствах для разработчиков программного обеспечения Intel](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html). На данный момент мы остановимся только на описании регистров общего назначения, так как в большинстве наших примеров мы будем использовать в основном именно их. Если мы будем использовать другие типы регистров, это будет упомянуто в соответствующем примере. Мы уже видели набор регистров общего назначения в [предыдущей главе](asm_1.md):

![registers](/content/assets/registers.png)

У нас есть `16` регистров размером 64 бита, от `rax` до `r15`. Некоторые части каждого `64-битного` регистра имеют собственное имя. Например, как мы можем видеть в таблице выше, нижние `32-бита` регистра `rax` называются `eax`. Таким же образом, нижние `16 бит` регистра `eax` называются `ax`. В конце концов, нижние `8 бит` регистра `ax` называются `al`, а верхние `8 бит` называются `ah`. Схематически это можно представить так:

![rax](./assets/rax.svg)

Регистры общего назначения используются во многих различных случаях, таких как выполнение арифметических и логических операций, передача данных, операции вычисления адреса памяти, передача параметров функциям и системным вызовам и многое другое. При прочтении этого и других постов мы увидим, как регистры общего назначения могут использоваться для выполнения различных операций.

### Порядок байтов

Компьютер оперирует байтами. Байты могут храниться в памяти в разном порядке. Этот порядок, в котором компьютер хранит последовательность байтов, собственно и называется - `порядком байтов`. Существует два типа:
- `big endian`
- `little endian`

Мы можем представить себе память как один большой массив байтов. Каждый байт имеет свой адрес. Например, предположим, что у нас в памяти есть следующие четыре байта: `AA 56 AB FF`. В порядке `little-endian` младший байт имеет наименьший адрес:

| Address            | Byte |
|--------------------|------|
| 0x0000000000000000 | 0xFF |
| 0x0000000000000001 | 0xAB |
| 0x0000000000000002 | 0x56 |
| 0x0000000000000003 | 0xAA |

В случае с `big-endian` байты хранятся в порядке, противоположном `little-endian`. Так что если взглянуть на тот же набор байтов - `AA 56 AB FF`, то результат будет таким:

| Address            | Byte |
|--------------------|------|
| 0x0000000000000000 | 0xAA |
| 0x0000000000000001 | 0x56 |
| 0x0000000000000002 | 0xAB |
| 0x0000000000000003 | 0xFF |

### Системные вызовы

[Системные вызовы](https://en.wikipedia.org/wiki/System_call) — это набор API, предоставляемый операционной системой. Программа уровня пользователя может использовать этот API для достижения различных функциональных возможностей, которые может предоставить ядро ​​операционной системы. Как упоминалось в предыдущей [главе](asm_1.md), вы можете найти все системные вызовы ядра Linux для архитектуры `x86_64` [здесь](https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl).

Существует два способа выполнения системного вызова. Мы можем вызвать библиотечную функцию, к примеру, [printf](https://man7.org/linux/man-pages/man3/fprintf.3.html), которая уже в свою очередь будет использовать API  Операционной Системы, или мы можем вызвать системный вызов самостоятельно, используя инструкцию `syscall`. Чтобы выполнить системный вызов напрямую, нам нужно подготовить параметры этой функции. Как мы видели в предыдущей части, для этой цели использовались некоторые регистры общего назначения. То, как вызываются системные вызовы и функции, и как передаются их параметры, называется - `соглашения о вызовах`. Для Linux `x86_64` соглашения о вызовах указаны в документе [System V Application Binary Interface](https://en.wikipedia.org/wiki/Application_binary_interface).

Давайте подробнее рассмотрим, как аргументы передаются в системный вызов, если мы собираемся вызвать его с помощью инструкции `syscall`.

Первые шесть параметров передаются в следующие регистры общего назначения:

- `rdi` - используется для передачи первого аргумента в функцию.
- `rsi` - используется для передачи второго аргумента в функцию.
- `rdx` - используется для передачи третьего аргумента в функцию.
- `r10` - используется для передачи четвертого аргумента в функцию.
- `r8` - используется для передачи пятого аргумента в функцию.
- `r9` - используется для передачи шестого аргумента в функцию.

Если мы используем какую-либо обертку пользовательского пространства вместо прямого вызова системного вызова, порядок регистров и параметров будет другим. На данный момент давайте сосредоточимся только на соглашениях о системных вызовов с использованием интерфейса ядра Linux. Номер системного вызова передается в регистре `rax`. После подготовки всех параметров системный вызов вызывается с помощью инструкции `syscall`. После завершения работы результат возвращается в регистре `rax`.

### Секции программы

Как мы уже видели в первом посте, каждая программа состоит из программных разделов (или сегментов). Каждый исполняемый файл в Linux x86_64 представлен в формате [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format). Каждый файл ELF имеет таблицу разделов, из которых состоит программа. Мы можем увидеть список разделов нашей программы `hello` из предыдущего поста с помощью утилиты [readelf](https://man7.org/linux/man-pages/man1/readelf.1.html):

```
~$ strip hello && readelf -S hello

There are 4 section headers, starting at offset 0x2028:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000401000  00001000
       0000000000000027  0000000000000000  AX       0     0     16
  [ 2] .data             PROGBITS         0000000000402000  00002000
       000000000000000d  0000000000000000  WA       0     0     4
  [ 3] .shstrtab         STRTAB           0000000000000000  0000200d
       0000000000000017  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)
```

Как мы видим, в программе есть четыре раздела. Два из них мы добавили сами во время написания ассемблерного кода. Дополнительные два раздела добавил компилятор. Технически мы можем самостоятельно раздел в исполняемом файле с любым названием. Но есть общеизвестные разделы:

- `data` - раздел используется для объявления инициализированных данных или констант.
- `bss` - раздел используется для объявления неинициализированных переменных.
- `text` - раздел используется для кода программы.
- `shstrtab` - раздел, в котором хранятся ссылки на существующие разделы.

### Типы данных

Очевидно, что ассемблер не является [статически типизированным языком программирования](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F). Обычно мы работаем с набором байтов. Несмотря на это, [NASM](https://nasm.us/) дает нам некоторые абстракции, по крайней мере, для определения размера данных, с которыми мы работаем. Основные типы данных:

- `байт`
- `слово`
- `двойное слов`
- `четверть-слово`
- `двойное четверть-слово`

Байт — это восемь бит, слово — это два байта, двойное слово — это четыре байта, четверть-слово — это восемь байтов, а двойное четверть-слово — это шестнадцать байтов. NASM предоставляет псевдоинструкции, которые помогут нам определить данные с заданным размером:

- `DB`
- `DW`
- `DD`
- `DQ`
- `DT`
- `DO`
- `DY`
- `DZ`

Псевдоинструкции от `DB` до `DQ` используются для определения данных размером от байта до двойного четверть-слова. `DT` используется для определения `10` байт. `DO` используется для определения `16` байт. `DY` используется для определения `32` байт. `DZ` используется для определения `64` байт. Кроме того, существуют альтернативы для определения неинициализированной памяти - `RESB`, `RESW`, `RESD`, `RESQ`, `REST`, `RESO`, `RESY` и `RESZ`.
Например:

```assembly
section .data
    ;; Define byte with the value 100
    num1   db 100
    ;; Define 2 bytes with the value 1024
    num2   dw 1024
    ;; Define set of characters (10 is ASCII \n)
    msg    db "Sum is correct", 10
```

Если мы обратимся к переменной, которая определена таким образом, мы получим ее адрес, но не фактическое значение. Если мы хотим получить фактическое значение, которое находится по данному адресу, нам нужно указать имя переменной в квадратных скобках:

```
;; Move the value of the num1 to the al register
mov al, [num1]
```

Размеры указателей имеют специальное обозначение:

```assembly
;; move 4 bytes value from the edi register to the address stored in the rbp register minus 4 bytes offset
mov     DWORD PTR [rbp-4], edi
```

Большую часть времени мы работаем с целочисленым типо(int). Существует два типа целых чисел:

- `unsigned int`
- `signed int`

Разница между этими двумя типами чисел в том, что первый не может принимать отрицательные числа. Отрицательные числа, представленные [доплнительным кодом](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4). В следующих постах мы также посмотрим, как представляются числа с плавающей точкой.

### Стек

Мы не можем и дальше рассматривать программирование на ассемблере, не зная одного из важнейших понятий архитектуры `x86_64` (и не только) - стека. Стек - это область памяти программы, доступ к которой осуществляется по шаблону [первым-зашел,последним-вышел](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)).

Процессор имеет очень ограниченное количество регистров. Как мы уже знаем, процессор `x86_64` дает нам доступ к `16` регистрам общего назначения. Это на самом деле не так много, и вполне возможно что нам потребуется больше или даже намного больше места для хранения наших данных. Один из способов решения этой проблемы - использование **стека** программы. По сути, мы можем рассматривать стек как обычную концепцию области памяти, но с единственным существенным отличием - шаблоном доступа. С обычной моделью [RAM](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BF%D0%BE%D0%BC%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B5%D0%B5_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE_%D1%81_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%BC_%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BE%D0%BC) мы можем получить доступ к любому байту памяти, доступному нашему приложению пользовательского пространства. Существуют две специальные инструкции, которые используются для помещения значения в стек и извлечения значения из него:

- `push` - помещает операнд в стек.
- `pop`   - извлекает операнд из стека.

Стек растет вниз от высоких адресов к низким. Поэтому, в основном, когда мы слышим про вершину стека, речь идет о самом низком адресе. Регистр общего назначения `rsp` всегда должны указывать на вершину стека. В разделе [[#Системные вызовы|системные вызовы]] мы видели, что первые шесть аргументов системного вызова передаются в регистры общего назначения. Согласно документу соглашений о вызовах:

> Системные вызовы ограничены шестью аргументами, ни один аргумент не передается напрямую в стек.

Получается, что доступного количества регистров общего назначения должно быть достаточно для выполнения любого системного вызова. Но что насчет других функций? Что, если у функции больше шести аргументов? В этом случае первые шесть параметров также передаются в регистрах общего назначения, а все последующие параметры передаются в стеке. Набор регистров общего назначения для вызова библиотечной функции немного отличается от набора регистров, используемых для системного вызова:

- `rdi` - используется для передачи первого аргумента функции.
- `rsi` - используется для передачи второго аргумента функции.
- `rdx` - используется для передачи третьего аргумента функции.
- `rcx` - используется для передачи четвертого аргумента функции.
- `r8`   - используется для передачи пятого аргумента функции.
- `r9`   - используется для передачи шестого аргумента функции.

Давайте посмотрим на ассемблерный код некоторых искусственных функций, написанных на языке программирования C:

```C
int foo(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8) {
    return arg1 + arg2 + arg3 + arg4 + arg5 + arg6 + arg7 + arg8;
}

int bar() {
    return foo(1, 2, 3, 4, 5, 6, 7, 8);
}
```

Если мы скомпилируем его и посмотрим на ассемблерный код, то увидим что-то вроде этого:

```assembly
bar:
        ;; Preserve the base pointer
        push    rbp
        ;; Preserve the stack pointer
        mov     rbp, rsp
        ;; Push the eight argument on the stack
        push    8
        ;; Push the seventh argument on the stack
        push    7
        ;; Push the sixth argument on the stack
        mov     r9d, 6
        ;; Push the fifth argument on the stack
        mov     r8d, 5
        ;; Push the fourth argument on the stack
        mov     ecx, 4
        ;; Push the third argument on the stack
        mov     edx, 3
        ;; Push the second argument on the stack
        mov     esi, 2
        ;; Push the first argument on the stack
        mov     edi, 1
        ;; Call the function `foo`
        call    foo
        ;; Clean-up the stack from the 8th and 7th arguments
        add     rsp, 16
        ;; Restore the old rbp
        leave
        ;; Return from the function
        ret
foo:
        ;; Preserve the base pointer
        push    rbp
        ;; Preserve the stack pointer
        mov     rbp, rsp
        ;; Move 4 bytes value from the edi register to the address stored in the rbp register minus 4 bytes offset
        mov     DWORD PTR [rbp-4], edi
        ;; Move 4 bytes value from the esi register to the address stored in the rbp register minus 8 bytes offset
        mov     DWORD PTR [rbp-8], esi
        ;; Move 4 bytes value from the edx register to the address stored in the rbp register minus 12 bytes offset
        mov     DWORD PTR [rbp-12], edx
        ;; Move 4 bytes value from the ecx register to the address stored in the rbp register minus 16 bytes offset
        mov     DWORD PTR [rbp-16], ecx
        ;; Move 4 bytes value from the r8d register to the address stored in the rbp register minus 20 bytes offset
        mov     DWORD PTR [rbp-20], r8d
        ;; Move 4 bytes value from the r9d register to the address stored in the rbp register minus 24 bytes offset
        mov     DWORD PTR [rbp-24], r9d
        ...
        ... # skip arithmetic operations for now
        ...
        ;; Restore the old rbp
        pop     rbp
        ;; Return from the function
        ret
```

> [!NOTE]
> Программа на языке C должна быть скомпилирована без каких-либо флагов оптимизации. Вы можете использовать флаги -O0 -masm=intel для компилятора, чтобы избежать ее. Также можете использовать такие инструменты, как godbolt, чтобы увидеть вывод сборки этих функций.

Прежде всего давайте посмотрим на первые две строки кода в функции `bar`:

```assembly
push    rbp
mov     rbp, rsp
```

Название этих двух инструкций в начале каждой функции - [пролог функции](https://en.wikipedia.org/wiki/Пролог_и_эпилог_функции#Пролог). Каждая функция обычно работает с частью стека. Такая часть называется [фреймом стека](https://en.wikipedia.org/wiki/Стек_вызовов). Для управления стеком процессор использует несколько регистров общего назначения:

- `rip`
- `rsp`
- `rbp`

Регистр общего назначения `rip` — это так называемый указатель инструкции (`instruction pointer`). Этот регистр хранит адрес следующей инструкции, которую собирается выполнить ЦП. Когда ЦП встречает инструкцию `call` для вызова функции, он помещает в стек адрес следующей инструкции после вызова функции. Это делается для того, чтобы знать, куда вернуться из вызванной функции.

Регистр `rsp` всегда указывает на `вершину` стека и называется - указателем стека(`stack pointer`). После того, как мы что-то помещаем в стек с помощью инструкции `push`, адрес указателя стека уменьшается. После того, как мы что-то извлекаем из стека с помощью инструкции `pop`, адрес указателя стека увеличивается.

Регистр общего назначения `rbp` - это так называемый указатель кадра(`frame pointer`) или указатель базы(`base pointer`). Как мы уже упоминали выше, каждая функция имеет свой `фрейм стека` - это область памяти, где функция хранит [локальные переменные](https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F) и другие данные.

Теперь, когда мы знаем приблизительное значение термина кадр стека и использование регистров `rbp`, `rsp` и `rip`, давайте попробуем понять, что происходит, когда мы вызываем функцию. Посмотрим на стек прямо перед выполнением `call foo`. Сейчас наш стек выглядит так:

![stack-before-call](./assets/stack-before-call.svg)

После выполнения инструкции `call` адрес возврата (или адрес следующей инструкции) помещается в стек. Таким образом, наша структура стека будет выглядеть уже следующим образом:

![stack-during-call](./assets/stack-during-call.svg)

Прямо в начале новой функции мы должны сохранить значение `rbp`, поместив его в стек. В это время регистр `rbp` содержит указатель базы предыдущей функции или, другими словами, можно сказать, что значение `rbp` в начале каждой функции представляет собой адрес дна (или базы) стека вызывающей функции. Поскольку мы находимся в новой функции - ей нужен новый кадр стека и, как следствие, новая база. После этого момента структура нашего стека будет выглядеть уже так:

![stack-preserve-bp](./assets/stack-preserve-bp.svg)

Следующий шаг — поместить значение текущего указателя стека в `rbp`. Начиная с этого момента у нас есть новый стековый кадр для функции `foo`. А поскольку стековый кадр готов, мы можем начать управлять параметрами функции и локальными переменными.

Первые шесть параметров функции `foo` были переданы с использованием регистров общего назначения в функцию `bar`. Мы можем увидеть, что восьмой и седьмой параметры функции `foo` помещаются в стек с помощью инструкций `push` в функции `bar`. Обратите внимание, что восьмой и седьмой аргументы функции `foo` помещаются в стек именно в таком порядке — сначала помещается значение `8` и только после него `7`. Выше мы уже упоминали, что стек имеет шаблон доступа — `первый-зашел, последним-ушел`. Поэтому, если бы мы использовали инструкцию `pop` сразу после того, как мы поместили эти оба параметра, мы бы получили сначала седьмой, а затем восьмой аргумент.

Для выполнения расчетов нам нужно получить доступ к входным параметрам. Как вы можете видеть, это делается с использованием адреса, хранящегося в регистре `rbp`, и смещений от него. Смещения отрицательные, поскольку вы, возможно, помните, что стек растет вниз в сторону меньших адресов. Сначала мы перемещаем значение, хранящееся в регистре `edi` (первый аргумент функции `foo`), по адресу, хранящемуся в регистре `rbp` со смещением `-4` (смещение отрицательное, поскольку вы должны помнить, что стек растет вниз) байт. После этого мы перемещаем значение, хранящееся в регистре `esi` (второй аргумент функции `foo`), по адресу, хранящемуся в регистре `rbp` со смещением `-8` байт. Мы повторяем эти операции для всех шести входных аргументов.

А теперь посмотрите еще раз, но уже очень внимательно

> на адрес, хранящийся в регистре `rbp` со смещением в `N` байт

Какой адрес хранился в `rbp`? Наш указатель стека! Итак, после последней инструкции `mov` в функции `foo` наш стековый кадр будет выглядеть так:

![stack](./assets/stack.svg)
Вот в чем весь смысл регистра `rbp`. Он играет роль якоря в функции или базовой точки. Используя положительные смещения, мы можем получить доступ к адресу возврата и параметрам, помещенным в стек вызывающей стороной, а используя отрицательные смещения, мы можем получить доступ к локальным переменным.

Прямо перед возвратом из функции `foo` мы можем увидеть так называемый [эпилог функции](https://en.wikipedia.org/wiki/Function_prologue_and_epilogue#Epilogue) мы восстанавливаем начальное значение `rbp`, удаляя его из стека. Последняя инструкция `ret` извлекает адрес возврата из стека, и выполнение продолжается с этого адреса.

## Примеры

После того, как мы разобрались с самыми важными концепциями, пришло время вернуться к самой интересной части — написанию программ. Давайте взглянем на нашу вторую простую программу на ассемблере. Программа возьмет два целых числа, получит сумму этих чисел и сравнит ее с третьим предопределенным числом. Если предопределенное число равно сумме, программа что-то выведет на экран, если нет — программа просто завершит работу.

Перед написанием кода нам нужно знать, как выполнять основные арифметические выражения и операции сравнения .

### Базовые арифметические инструкции

Вот список некоторых инструкций ассемблера для выполнения арифметических операций:

- `ADD`  - Сложение.
- `SUB`  - Вычитание.
- `MUL`  - Беззнаковое умножение.
- `IMUL` - Знаковое умножение
- `DIV`  - Беззнаковое деление.
- `IDIV` - Знаковое деление.
- `INC`  - Инкрементирование.
- `DEC`  - Декрементирование.
- `NEG`  - Отрицание.

Все подробности, связанные с приведенными выше инструкциями, будут описаны в примере далее.

### Инструкции потока управления

Теперь давайте взглянем на наши первые инструкции [управления потоком](https://en.wikipedia.org/wiki/Control_flow). Обычно языки программирования имеют возможность изменять порядок выполнения (например, с помощью операторов `if` или `case`, `goto` и т. д.). Язык программирования ассемблера также предоставляет самую базовую возможность изменять порядок выполнения наших программ. Первая такая инструкция - `cmp`. Эта инструкция принимает два значения и выполняет сравнение между ними. Обычно она используется вместе с инструкцией условного перехода. Например:

```assembly
;; compare value of the rax register with 50
cmp rax, 50
```

Инструкция `cmp` выполняет только сравнивает свои операнды, не влияя на их значения. Для выполнения каких-либо действий после сравнения существуют инструкции условного перехода. Список этих инструкций:

-  `JE`   - Перейти если значения равны
-  `JNE` - Перейти если значения не равны.
-  `JZ`   - Перейти если разница между значениями равна нулю.
-  `JNZ` - Перейти если разница между значениями не равна нулю.
-  `JG`   - Перейти если первое значение больше второго.
-  `JGE` - Перейти если первое значение больше либо равно второму.
-  `JA`   - То же что и `JG`, но для знакового сравнения.
-  `JAE` - То же что и `JGE`, но для беззнакового сравнения.

Например, если мы хотим получить что-то вроде этого оператора if/else, написанного на языке C:

```C
if (rax != 50) {
    foo();
} else {
    bar();
}
```

на ассемблере, нам стоит написать следующее:

```assembly
;; compare rax with 50
cmp rax, 50
;; jump to the label `.foo` if the value of the `rax` register is not equal to 50
jne .foo
;; jump to the label `.bar` otherwise
jmp .bar
```

Кроме того, мы можем перейти на метку вобще без каких-либо условий с помощью инструкции `jmp`:

```assembly
jmp .label
```

Часто безусловные переходы используются для имитации цикла. Например, у нас есть метка и некоторый код после нее. Этот код выполняет что угодно, затем у нас есть условие и переход к началу этого кода, если условие не выполняется.
Циклы будут рассмотрены в следующих частях.

### Пример программы

Поскольку мы уже изучили некоторые основные арифметические и управляющие инструкции, мы можем написать наш пример. Но прежде чем мы взглянем на исходный код программы, я напомню, что мы собираемся написать простую программу, которая вычислит сумму двух целых чисел, и если сумма будет равна третьему предопределенному числу, мы выведем строку. В противном случае ничего не делает.

Вот исходный код нашего примера:

```assembly
```assembly
    ;; Set the value of the num1 to the rax
    mov rax, [num1]
    ;; Set the value of the num2 to the rbx
    mov rbx, [num2]
    ;; Get sum of the rax and rbx. The result is stored in the rax.
    add rax, rbx
.compare:
    ;; Compare the value of the rax with `150`
    cmp rax, 150
    ;; Go to the .exit label if the values of the rax and 150 are not equal
    jne .exit
    ;; Go to the .correctSum label if the values of the rax and 150 are equal
    jmp .correctSum

; Print message that the sum is correct
.correctSum:
    ;; Number of the system call. 1 - `sys_write`.
    mov rax, 1
    ;; The first argument of the `sys_write` system call. 1 is `stdout`.
    mov rdi, 1
    ;; The second argument of the `sys_write` system call. Reference to the message.
    mov rsi, msg
    ;; The third argument of the `sys_write` system call. Length of the message.
    mov rdx, 20
    ;; Call the `sys_write` system call.
    syscall
    ; Go to the exit of the program.
    ;; Set the value of num1 to rax
    mov rax, [num1]
    ;; Set the value of num2 to rbx
    mov rbx, [num2]
    ;; Get the sum of rax and rbx. The result is stored in rax.
    add rax, rbx
.compare:
    ;; Compare the rax value with 150
    cmp rax, 150
    ;; Go to the .exit label if the rax value is not 150
    jne .exit
    ;; Go to the .correctSum label if the rax value is 150
    jmp .correctSum

;; Print a message that the sum is correct
.correctSum:
    ;; Specify the system call number (1 is `sys_write`).
    mov rax, 1
    ;; Set the first argument of `sys_write` to 1 (`stdout`).
    mov rdi, 1
    ;; Set the second argument of `sys_write` to the reference of the `msg` variable.
    mov rsi, msg
    ;; Set the third argument to the length of the `msg` variable's value (20 bytes).
    mov rdx, 20
    ;; Call the `sys_write` system call.
    syscall
    ;; Go to the exit of the program.
    jmp .exit

;; Exit procedure
.exit:
    ;; Specify the number of the system call (60 is `sys_exit`).
    mov rax, 60
    ;; Set the first argument of `sys_exit` to 0. The 0 status code is success.
    mov rdi, 0
    ;; Call the `sys_exit` system call.
    syscall
```

Для начала попробуем собрать и запустить нашу программу с помощью команд, которые,  мы видели в предыдущей главе, и посмотрим на результат:

```bash
$ nasm -f elf64 -o program.o program.asm
$ ld -o program program.o
```

После того, как мы создали нашу программу, мы можем запустить ее с помощью:

```bash
~$ ./program
Sum is correct
```

Теперь давайте пройдемся по исходному коду нашей программы. В первую очередь это раздел `.data` с тремя переменными:

- `num1`
- `num2`
- `msg`

Точкой входа нашей программы является символ `_start`. В начале исходного кода нашей программы мы помещаем значения `num1` и `num2` в регистры общего назначения `rax` и `rbx`. После этого мы можем использовать инструкцию `add`, чтобы получить сумму этих двух значений. Результат суммы будет сохранен в регистре `rax`.

Согласно описанию нашей программы, теперь нам нужно сравнить сумму двух чисел с третим, но уже предопределенным числом. Мы делаем это с помощью инструкции `cmp`. На этом этапе у нас есть два пути. Первый - мы переходим на метку `.exit`, если значение `rax` (где хранится сумма значений `num1` и `num2`) не равно `150`. Если сумма равна `150`, то переходим на метку `.correctSum`.

Исходный код подпрограмм `.correctSum` и `.exit` должен быть нам знаком. Они обе делают схожие вещи, которые мы уже видели в предыдущей главе. Подпрограмма `.correctSum` выводит строку из `msg` на экран. Подпрограмма `.exit` обеспечивает нам изящный выход из нашей программы.

На этом всё в этом главе. В следующей мы продолжим углубляться в программирование на ассемблере.
